using InverseIsing
using StatsBase:sample
using JSON
using PyCall
@pyimport sklearn.metrics as met

function estim_test1()
    samples = [1 -1 -1;-1 1 1]
    model = GBM(size(samples, 2))
    fit(model, samples)
    W_fit = infer(model)
    @test W_fit == [0 -1 -1;-1 0 1;-1 1 0]
    @test decode(W_fit) == Dict((1, 2) => -1, (1, 3) => -1, (2, 3) => 1)
end

function estim_test2()
    n_unit = 5 # Number of units
    rate = 0.9 # zero rate (in all interaction-pairs)
    h = Dict()
    J_idx = [(i,j) for i in 1:n_unit for j in i+1:n_unit]
    len = length(J_idx)
    J_val = Int.(ones(len))
    J_val[sample(1:len, Int(ceil(len * rate)), replace=false)] .= 0
    J = Dict(zip(J_idx, J_val))

    # annealing and create samples
    resp = anneal(h, J, n_read=1000)
    samples = hcat(resp.states...)'

    # inverse ising inference
    model = GBM(n_unit)
    fit(model, samples)
    pred = decode(infer(model))
    @test J == pred
end

function estim_test3()
    # read spin samples generated by openjij [https://github.com/OpenJij/OpenJij]
    data = Dict()
    open("./spin_samples/sample_3.json","r") do f
               data = JSON.parse(f)["sample1"]
           end

    actualJ = Array{Int64}(hcat(data["actualJ"]...))
    actualJ = actualJ + actualJ'
    samples = Array{Float64}(hcat(data["samples"]...)')

    # fitting model parameters to samples
    n_unit = data["n_unit"]
    model = GBM(n_unit)
    fit(model, samples, delta=0.1)

    # calculation roc curve & auc
    interact_idx = [(i, j) for i in 1:n_unit for j in i+1:n_unit]
    y_true = [actualJ[i,j] for (i,j) in interact_idx]
    y_pred = [model.W[i, j] for (i,j) in interact_idx]
    fpr, tpr, thresholds = met.roc_curve(y_true, y_pred, drop_intermediate=false)
    @test  met.auc(fpr, tpr) >= 0.9
end

@testset "Test estim" begin
    estim_test1()
    estim_test2()
    estim_test3()
end
